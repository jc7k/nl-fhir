# Story 4.1: Adaptive FHIR Bundle Summarizer Framework

## Story Overview

**Epic:** Epic 4 - FHIR Bundle Summarization with Adaptive Cost Optimization  
**Story ID:** 4.1  
**Title:** Adaptive FHIR Bundle Summarizer Framework  
**Status:** Ready for Development  
**Estimate:** 8 story points  
**Sprint:** Sprint 4 Week 1-2  

## User Story

**As a** healthcare application administrator  
**I want** a cost-optimized FHIR bundle summarization system with multiple processing tiers  
**So that** we can provide consistent clinical summaries while minimizing operational LLM costs through intelligent routing  

## Acceptance Criteria

### AC1: Multi-Tier Processing Architecture
- [ ] **GIVEN** a HAPI-validated FHIR bundle
- [ ] **WHEN** the system analyzes bundle resource composition  
- [ ] **THEN** it routes to appropriate processing tier (Rule-based, Template, or LLM)
- [ ] **AND** maintains consistent output format across all tiers

### AC2: FHIRBundleSummarizer Core Engine  
- [ ] **GIVEN** various FHIR bundle types (medication, procedure, diagnostic, emergency)
- [ ] **WHEN** the primary engine processes the bundle
- [ ] **THEN** it correctly classifies resources and selects optimal processing tier
- [ ] **AND** provides graceful fallback between tiers when needed

### AC3: ResourceSummarizer Registry System
- [ ] **GIVEN** different FHIR resource types in bundles
- [ ] **WHEN** the system encounters known resource patterns
- [ ] **THEN** it uses registered rule-based summarizers for cost optimization
- [ ] **AND** falls back to generic processing for unknown resource types

### AC4: Production Monitoring Integration
- [ ] **GIVEN** all summarization requests  
- [ ] **WHEN** processing occurs at any tier
- [ ] **THEN** system logs SummarizationEvent with tier usage and performance metrics
- [ ] **AND** tracks cost optimization effectiveness over time

## Technical Requirements

### Core Architecture Components

**FHIRBundleSummarizer (Primary Engine):**
```python
class FHIRBundleSummarizer:
    """
    Main orchestrator for adaptive FHIR bundle summarization
    Routes bundles through optimal processing tiers based on content analysis
    """
    
    def __init__(self):
        self.resource_registry = ResourceSummarizerRegistry()
        self.monitoring = ProductionMonitoringMixin()
        self.generic_engine = GenericTemplateEngine()
        self.llm_service = StructuredLLMService()
    
    async def summarize_bundle(self, fhir_bundle: Dict[str, Any], 
                             role: str = "physician") -> ClinicalSummary:
        # Tier selection and processing logic
        
    def _analyze_bundle_composition(self, bundle: Dict) -> BundleAnalysis:
        # Resource classification and complexity assessment
        
    def _select_processing_tier(self, analysis: BundleAnalysis) -> ProcessingTier:
        # Intelligent tier selection based on resource patterns
```

**ResourceSummarizerRegistry:**
```python
class ResourceSummarizerRegistry:
    """
    Registry for rule-based resource summarizers
    Enables extensible, deterministic processing for common FHIR resources
    """
    
    def __init__(self):
        self._summarizers = {
            'MedicationRequest': MedicationSummarizer(),
            'ServiceRequest': ServiceSummarizer(), 
            'DiagnosticReport': DiagnosticSummarizer(),
            'Procedure': ProcedureSummarizer(),
        }
    
    def get_summarizer(self, resource_type: str) -> Optional[ResourceSummarizer]:
        # Return appropriate rule-based summarizer
        
    def register_summarizer(self, resource_type: str, summarizer: ResourceSummarizer):
        # Enable runtime registration of new summarizers
```

**ProcessingTier Enum:**
```python
class ProcessingTier(Enum):
    RULE_BASED = "rule_based"      # Tier 1: Deterministic processing
    GENERIC_TEMPLATE = "generic"    # Tier 2: Template-based processing  
    LLM_FALLBACK = "llm_fallback"  # Tier 3: LLM-powered processing
```

### Monitoring and Event Tracking

**SummarizationEvent Model:**
```python
@dataclass
class SummarizationEvent:
    """Event tracking for all summarization processing decisions"""
    timestamp: datetime
    request_id: str
    bundle_id: str
    resource_types: List[str]
    tier_used: ProcessingTier
    processing_time_ms: float
    fallback_occurred: bool
    cost_impact: Optional[float]  # Estimated cost for LLM usage
    quality_score: Optional[float]
```

**ProductionMonitoringMixin:**
```python
class ProductionMonitoringMixin:
    """Comprehensive monitoring for cost optimization and quality tracking"""
    
    def log_summarization_event(self, event: SummarizationEvent):
        # Log processing decisions and performance metrics
        
    def calculate_tier_usage_percentage(self, window_hours: int = 24) -> Dict[str, float]:
        # Real-time tier usage analytics
        
    def trigger_cost_alerts(self, llm_usage_percent: float):
        # Automated alerting when LLM usage exceeds thresholds
```

## Implementation Details

### File Structure
```
src/nl_fhir/services/summarization/
├── fhir_bundle_summarizer.py         # Main orchestrator class
├── resource_summarizer_registry.py   # Registry and base classes
├── rule_based/                       # Tier 1: Rule-based processors
│   ├── medication_summarizer.py
│   ├── procedure_summarizer.py
│   └── diagnostic_summarizer.py
├── generic_template_engine.py        # Tier 2: Template processor
├── structured_llm_service.py         # Tier 3: LLM integration
├── monitoring/                       # Production monitoring
│   ├── events.py                     # Event models and tracking
│   └── cost_analytics.py             # Cost optimization analytics
└── models/                           # Shared data models
    ├── clinical_summary.py           # Output models
    └── bundle_analysis.py             # Analysis models
```

### Tier Selection Logic

**Bundle Classification Rules:**
```python
def _classify_bundle_complexity(self, analysis: BundleAnalysis) -> ProcessingTier:
    # Tier 1: Rule-based (Target: 70-80% of bundles)
    if all(rt in self.resource_registry.supported_types for rt in analysis.resource_types):
        if analysis.complexity_score < 3 and not analysis.has_rare_resources:
            return ProcessingTier.RULE_BASED
    
    # Tier 2: Generic Template (Target: 15-20% of bundles)  
    if analysis.complexity_score < 6 and len(analysis.resource_types) <= 4:
        return ProcessingTier.GENERIC_TEMPLATE
        
    # Tier 3: LLM Fallback (Target: 5-10% of bundles)
    return ProcessingTier.LLM_FALLBACK
```

## Testing Requirements

### Unit Tests
- [ ] Test tier selection logic with various bundle compositions
- [ ] Validate ResourceSummarizerRegistry registration and retrieval
- [ ] Test monitoring event logging and analytics calculations
- [ ] Verify fallback logic when rule-based processing fails

### Integration Tests  
- [ ] End-to-end bundle processing through all three tiers
- [ ] Cost optimization validation (LLM usage <10% of total requests)
- [ ] Performance testing across processing tiers (<500ms requirement)
- [ ] Monitoring system integration and alert generation

### Test Data Scenarios
- Simple medication bundles (should use Tier 1: Rule-based)
- Complex multi-resource bundles (should use Tier 2: Generic template)  
- Novel/rare resource bundles (should use Tier 3: LLM fallback)
- High-volume processing simulation for cost optimization validation

## Definition of Done

- [ ] FHIRBundleSummarizer implements multi-tier processing architecture
- [ ] ResourceSummarizerRegistry supports runtime registration and lookup
- [ ] Production monitoring tracks tier usage and cost optimization metrics
- [ ] Tier selection logic routes 70-80% of bundles to rule-based processing
- [ ] All tiers produce consistent ClinicalSummary output format
- [ ] Integration tests validate end-to-end processing and fallback logic
- [ ] Cost optimization targets achieved (<10% LLM usage in test scenarios)
- [ ] Code review completed and approved
- [ ] Documentation updated with architecture diagrams and usage examples

## Dependencies

**Blocked By:**
- Epic 3 completion (HAPI-validated FHIR bundles)

**Blocks:**
- Story 4.2 (Rule-Based Summarization Engine) - requires framework foundation
- Story 4.3 (Production Monitoring System) - requires event tracking models  
- Story 4.4 (Generic Template & LLM Integration) - requires tier architecture

**External Dependencies:**
- Pydantic v2 for data models
- Python asyncio for performance optimization
- Structured logging framework for monitoring events

## Notes for Development

**Key Architecture Principles:**
1. **Cost-First Design:** Minimize LLM usage through intelligent tier selection
2. **Extensibility:** Registry pattern enables easy addition of new resource summarizers
3. **Monitoring-Driven:** Comprehensive event tracking for optimization insights
4. **Fallback Resilience:** Graceful degradation ensures system reliability
5. **Performance Consistency:** <500ms response time across all processing tiers

**Implementation Priority:**
1. Build core FHIRBundleSummarizer orchestrator with tier selection logic
2. Implement ResourceSummarizerRegistry with base interfaces
3. Add production monitoring and event tracking infrastructure  
4. Create integration points for rule-based, template, and LLM processors
5. Develop comprehensive test suite with cost optimization validation

**Cost Optimization Strategy:**
- Target 70-80% rule-based processing for maximum cost savings
- Use generic templates for 15-20% of moderately complex bundles  
- Reserve LLM processing for <10% of highly complex or novel bundles
- Implement sliding window monitoring to track and alert on cost trends