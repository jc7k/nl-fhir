# Story 4.3: Production Monitoring and Cost Control System

## Story Overview

**Epic:** Epic 4 - FHIR Bundle Summarization with Adaptive Cost Optimization  
**Story ID:** 4.3  
**Title:** Production Monitoring and Cost Control System  
**Status:** Ready for Development  
**Estimate:** 6 story points  
**Sprint:** Sprint 4 Week 3  

## User Story

**As a** healthcare system operations manager  
**I want** comprehensive monitoring of FHIR summarization costs and processing tier usage  
**So that** I can proactively manage LLM costs, optimize system performance, and trigger code reviews when usage patterns drift from targets  

## Acceptance Criteria

### AC1: Real-Time Tier Usage Monitoring
- [ ] **GIVEN** ongoing FHIR bundle processing across all three tiers
- [ ] **WHEN** summarization requests are processed  
- [ ] **THEN** system tracks tier usage percentages in real-time with sliding window calculations
- [ ] **AND** provides dashboards showing Rule-based (target 70-80%), Template (15-20%), LLM (5-10%) usage

### AC2: Automated Cost Alerting System  
- [ ] **GIVEN** configured cost thresholds and baseline LLM usage patterns
- [ ] **WHEN** LLM usage exceeds target thresholds by 20-30%
- [ ] **THEN** system automatically triggers alerts via Slack/email with detailed usage analytics
- [ ] **AND** schedules code review sessions when sustained threshold violations occur

### AC3: Comprehensive Event Tracking
- [ ] **GIVEN** all summarization processing activities
- [ ] **WHEN** any tier processes a FHIR bundle
- [ ] **THEN** system logs detailed SummarizationEvent with processing decisions, timing, and cost impact
- [ ] **AND** enables drill-down analysis of processing patterns and optimization opportunities

### AC4: Smart Throttling and Cost Protection
- [ ] **GIVEN** unexpected LLM usage spikes or system abuse scenarios
- [ ] **WHEN** cost thresholds are exceeded within short time windows
- [ ] **THEN** system implements intelligent throttling to protect against cost overruns
- [ ] **AND** maintains service availability while controlling operational expenses

## Technical Requirements

### Core Monitoring Infrastructure

**ProductionMonitoringMixin:**
```python
class ProductionMonitoringMixin:
    """
    Comprehensive production monitoring for adaptive FHIR summarization
    Provides cost tracking, usage analytics, and automated alerting
    """
    
    def __init__(self):
        self.event_logger = SummarizationEventLogger()
        self.usage_tracker = TierUsageTracker()
        self.alert_manager = CostAlertManager()
        self.throttling_controller = ThrottlingController()
    
    async def log_summarization_event(self, event: SummarizationEvent):
        """Log processing event with cost and performance tracking"""
        await self.event_logger.log_event(event)
        await self.usage_tracker.update_usage_metrics(event)
        await self._check_cost_thresholds(event)
    
    async def get_tier_usage_analytics(self, window_hours: int = 24) -> TierUsageAnalytics:
        """Real-time tier usage percentages and trends"""
        
    async def _check_cost_thresholds(self, event: SummarizationEvent):
        """Automated threshold monitoring and alert triggering"""
```

**SummarizationEvent Model:**
```python
@dataclass
class SummarizationEvent:
    """Comprehensive event tracking for all processing decisions"""
    
    # Core identification
    timestamp: datetime
    request_id: str
    bundle_id: str
    session_id: Optional[str]
    
    # Resource analysis
    resource_types: List[str]
    resource_count: int
    bundle_complexity_score: float
    has_rare_resources: bool
    
    # Processing decisions  
    tier_selected: ProcessingTier
    tier_fallback_occurred: bool
    fallback_reason: Optional[str]
    
    # Performance metrics
    analysis_time_ms: float
    processing_time_ms: float
    total_time_ms: float
    
    # Cost impact (LLM usage only)
    llm_tokens_used: Optional[int]
    estimated_cost_usd: Optional[float]
    
    # Quality indicators
    output_quality_score: Optional[float]
    user_satisfaction_rating: Optional[int]
    
    # System context
    server_instance: str
    api_version: str
    user_role: str
    specialty_context: Optional[str]  # cardiology, emergency, etc.
```

### Real-Time Analytics and Dashboards

**TierUsageTracker:**
```python
class TierUsageTracker:
    """
    Real-time tracking of processing tier usage with sliding window analytics
    Supports configurable time windows and baseline calculations
    """
    
    def __init__(self):
        self.sliding_windows = {
            'hourly': SlidingWindowCounter(window_size=3600),
            'daily': SlidingWindowCounter(window_size=86400),
            'weekly': SlidingWindowCounter(window_size=604800)
        }
        self.baseline_calculator = BaselineCalculator()
    
    async def update_usage_metrics(self, event: SummarizationEvent):
        """Update tier usage counters across all time windows"""
        
    async def get_current_usage_percentages(self, window: str = 'daily') -> Dict[ProcessingTier, float]:
        """Real-time tier usage percentages"""
        
    async def calculate_cost_optimization_score(self) -> float:
        """Overall cost optimization effectiveness (0.0-1.0)"""
        
    async def detect_usage_drift(self) -> List[UsageDriftAlert]:
        """Identify significant deviations from expected usage patterns"""
```

**BaselineCalculator:**
```python  
class BaselineCalculator:
    """
    Intelligent baseline calculation for different medical specialties
    Adapts to changing usage patterns while maintaining cost control
    """
    
    def __init__(self):
        self.specialty_baselines = {
            'emergency': {'rule_based': 0.65, 'template': 0.25, 'llm': 0.10},
            'cardiology': {'rule_based': 0.75, 'template': 0.20, 'llm': 0.05},
            'oncology': {'rule_based': 0.60, 'template': 0.25, 'llm': 0.15},
            'general': {'rule_based': 0.75, 'template': 0.18, 'llm': 0.07}
        }
    
    async def calculate_adaptive_baseline(self, specialty: str, 
                                        historical_data: List[SummarizationEvent]) -> Dict[ProcessingTier, float]:
        """Calculate context-aware baselines with intelligent adaptation"""
        
    async def detect_system_changes(self, recent_events: List[SummarizationEvent]) -> List[SystemChangeEvent]:
        """Identify significant system behavior changes requiring baseline updates"""
```

### Automated Alerting and Notifications

**CostAlertManager:**
```python
class CostAlertManager:
    """
    Automated alerting system for cost optimization and usage pattern monitoring
    Supports multiple notification channels and intelligent alert throttling
    """
    
    def __init__(self):
        self.notification_channels = {
            'slack': SlackNotifier(),
            'email': EmailNotifier(), 
            'dashboard': DashboardNotifier()
        }
        self.alert_throttling = AlertThrottlingController()
        self.escalation_manager = EscalationManager()
    
    async def evaluate_cost_thresholds(self, current_usage: TierUsageAnalytics):
        """Evaluate current usage against configured thresholds"""
        
        if current_usage.llm_percentage > self.config.llm_alert_threshold:
            await self._trigger_cost_alert(AlertLevel.WARNING, current_usage)
            
        if current_usage.llm_percentage > self.config.llm_critical_threshold:
            await self._trigger_cost_alert(AlertLevel.CRITICAL, current_usage)
            await self.escalation_manager.schedule_code_review()
    
    async def _trigger_cost_alert(self, level: AlertLevel, usage_data: TierUsageAnalytics):
        """Send multi-channel alerts with usage analytics and recommendations"""
```

**Alert Configuration:**
```python
@dataclass
class CostMonitoringConfig:
    """Configuration for cost monitoring thresholds and alerting"""
    
    # Baseline thresholds (percentage of total requests)
    rule_based_target: float = 0.75      # Target: 75% rule-based processing
    template_target: float = 0.18        # Target: 18% template processing  
    llm_target: float = 0.07             # Target: 7% LLM processing
    
    # Alert thresholds (percentage above baseline)
    llm_warning_threshold: float = 0.20   # Alert when LLM usage +20% above target
    llm_critical_threshold: float = 0.30  # Critical when LLM usage +30% above target
    
    # Time windows for evaluation
    alert_evaluation_window_hours: int = 4
    baseline_calculation_window_days: int = 7
    
    # Cost protection
    max_llm_requests_per_hour: int = 100
    cost_protection_enabled: bool = True
    
    # Code review triggers
    sustained_violation_hours: int = 8    # Hours before scheduling code review
    code_review_cooldown_days: int = 7    # Minimum days between code reviews
```

### Smart Throttling and Cost Protection

**ThrottlingController:**
```python
class ThrottlingController:
    """
    Intelligent throttling system to protect against unexpected cost spikes
    Implements adaptive rate limiting while maintaining service quality
    """
    
    def __init__(self):
        self.rate_limiter = AdaptiveRateLimiter()
        self.cost_estimator = CostEstimator()
        self.service_degradation = ServiceDegradationController()
    
    async def should_throttle_request(self, request_context: RequestContext) -> ThrottlingDecision:
        """Intelligent throttling decision based on current usage and cost projections"""
        
    async def apply_throttling_strategy(self, decision: ThrottlingDecision) -> ThrottlingResult:
        """Apply appropriate throttling strategy based on current conditions"""
        
        if decision.strategy == ThrottlingStrategy.RATE_LIMIT:
            return await self.rate_limiter.apply_rate_limit(decision.parameters)
        elif decision.strategy == ThrottlingStrategy.DEGRADE_TO_TEMPLATE:
            return await self.service_degradation.force_template_processing(decision.request_id)
        elif decision.strategy == ThrottlingStrategy.QUEUE_REQUEST:
            return await self.service_degradation.queue_for_later_processing(decision.request_id)
```

## Implementation Details

### File Structure
```
src/nl_fhir/services/summarization/monitoring/
├── __init__.py                       # Monitoring exports
├── production_monitoring.py          # ProductionMonitoringMixin
├── events/                           # Event tracking and logging
│   ├── event_models.py               # SummarizationEvent and related models
│   ├── event_logger.py               # Event persistence and retrieval
│   └── event_analytics.py            # Event analysis and reporting
├── usage_tracking/                   # Tier usage monitoring
│   ├── tier_usage_tracker.py         # Real-time usage tracking
│   ├── sliding_window_counter.py     # Time window analytics
│   └── baseline_calculator.py        # Adaptive baseline calculation
├── alerting/                         # Automated alerting system
│   ├── alert_manager.py              # CostAlertManager implementation
│   ├── notification_channels.py      # Slack, email, dashboard notifiers
│   └── escalation_manager.py         # Code review and escalation logic
├── throttling/                       # Cost protection and throttling
│   ├── throttling_controller.py      # Smart throttling implementation
│   ├── rate_limiter.py               # Adaptive rate limiting
│   └── service_degradation.py        # Graceful service degradation
└── dashboards/                       # Monitoring dashboards and APIs
    ├── monitoring_api.py              # REST API for monitoring data
    ├── dashboard_models.py            # Dashboard data models
    └── cost_analytics_service.py      # Cost analysis and reporting
```

## Testing Requirements

### Unit Tests
- [ ] Test sliding window counter accuracy with various time windows
- [ ] Validate alert threshold calculations and triggering logic
- [ ] Test throttling controller decision-making under various load conditions
- [ ] Verify event logging completeness and performance

### Integration Tests  
- [ ] End-to-end monitoring integration with FHIRBundleSummarizer
- [ ] Alert system integration testing with mock notification channels
- [ ] Cost protection system testing with simulated usage spikes
- [ ] Dashboard API integration and data consistency validation

### Performance Tests
- [ ] High-volume event logging performance and storage efficiency
- [ ] Real-time analytics calculation performance under load
- [ ] Memory usage optimization for sliding window data structures

### Simulation Tests
- [ ] Cost spike simulation and throttling response validation
- [ ] Specialty-based usage pattern simulation and baseline adaptation
- [ ] Long-term usage drift detection and code review triggering

## Definition of Done

- [ ] ProductionMonitoringMixin implements comprehensive event tracking and analytics
- [ ] Real-time tier usage monitoring with configurable sliding windows
- [ ] Automated cost alerting system with multi-channel notifications
- [ ] Smart throttling system protects against unexpected cost spikes
- [ ] Baseline calculation adapts to different medical specialties and system changes
- [ ] Code review trigger system based on sustained threshold violations
- [ ] Monitoring dashboard APIs provide real-time cost and usage analytics
- [ ] Integration tests validate end-to-end monitoring functionality
- [ ] Performance tests confirm system handles high-volume production loads
- [ ] Documentation includes monitoring configuration and alert setup guides
- [ ] Code review completed and approved

## Dependencies

**Blocked By:**
- Story 4.1 (Adaptive Framework) - requires SummarizationEvent integration points

**Blocks:**
- Story 4.4 (LLM Integration) - provides cost tracking for LLM usage optimization

**External Dependencies:**
- Slack API for alert notifications
- Email service for alert delivery
- Time-series database for event storage (optional)
- Dashboard framework for monitoring UI

## Notes for Development

**Cost Optimization Priorities:**
1. **Proactive Monitoring:** Detect usage pattern drift before costs become problematic
2. **Intelligent Alerting:** Avoid alert fatigue through smart throttling and escalation
3. **Adaptive Baselines:** Account for different medical specialties and evolving system usage
4. **Cost Protection:** Implement safeguards against unexpected cost spikes or system abuse

**Production Reliability:**
- Event logging must not impact processing performance (<10ms overhead)
- Monitoring system failures should not affect core summarization functionality
- Alert systems must be highly available with multiple notification channels
- Throttling should maintain service quality while protecting against cost overruns

**Extensibility Design:**
- Plugin architecture for additional notification channels
- Configurable thresholds and baseline calculations
- Support for custom alerting rules and escalation procedures
- API-driven monitoring integration with external systems

**Security and Privacy:**
- Event logging excludes PHI and sensitive patient information
- Alert notifications contain only aggregate usage data and system metrics
- Monitoring APIs require appropriate authentication and authorization
- Audit logging for monitoring system access and configuration changes