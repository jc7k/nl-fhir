# Story 4.4: Clinical Summary API & Integration

## Story Overview

**Epic:** Epic 4 - FHIR Bundle Summarization  
**Story ID:** 4.4  
**Title:** Clinical Summary API & Integration  
**Status:** Ready for Development  
**Estimate:** 8 story points  
**Sprint:** Sprint 4 Week 4  

## User Story

**As a** clinical application integrating with NL-FHIR  
**I want** reliable API endpoints for FHIR bundle summarization  
**So that** I can provide physicians with consistent clinical summaries for order verification  

## Acceptance Criteria

### AC1: FastAPI Endpoint Implementation
- [ ] **GIVEN** a HAPI-validated FHIR bundle and clinical role specification  
- [ ] **WHEN** calling the summarization API endpoint
- [ ] **THEN** it returns a structured clinical summary in <500ms
- [ ] **AND** includes proper error handling and status codes

### AC2: Request Tracking and Monitoring
- [ ] **GIVEN** API requests for clinical summaries
- [ ] **WHEN** processing requests
- [ ] **THEN** each request is tracked with unique identifiers
- [ ] **AND** performance metrics are collected for monitoring

### AC3: Clinical Workflow Integration  
- [ ] **GIVEN** various clinical roles and workflow contexts
- [ ] **WHEN** requesting summaries
- [ ] **THEN** the API supports role-based customization
- [ ] **AND** provides appropriate response formats for integration

### AC4: Production Readiness
- [ ] **GIVEN** production deployment requirements
- [ ] **WHEN** the API is deployed  
- [ ] **THEN** it includes proper logging, monitoring, and error handling
- [ ] **AND** meets performance and reliability standards

## Technical Requirements

### FastAPI Endpoint Specification

**Primary Endpoint:**
```python
@app.post("/fhir/summarize", response_model=ClinicalSummaryResponse)
async def summarize_fhir_bundle(
    request: FHIRSummarizationRequest,
    clinical_role: str = "physician"
) -> ClinicalSummaryResponse:
    """
    Generate structured clinical summary from HAPI-validated FHIR bundle
    """
```

**Request Model:**
```python
class FHIRSummarizationRequest(BaseModel):
    fhir_bundle: Dict[str, Any] = Field(description="HAPI-validated FHIR R4 bundle")
    clinical_role: str = Field(default="physician", description="Target clinical role")
    request_context: Optional[str] = Field(description="Additional clinical context")
    priority: str = Field(default="routine", description="Processing priority")
    
    class Config:
        schema_extra = {
            "example": {
                "fhir_bundle": {"resourceType": "Bundle", "entry": [...]},
                "clinical_role": "physician", 
                "request_context": "post-procedure review",
                "priority": "routine"
            }
        }
```

**Response Model:**  
```python
class ClinicalSummaryResponse(BaseModel):
    status: Literal["success", "error", "partial"]
    request_id: str
    processing_time_ms: float
    schema_used: str
    clinical_summary: Union[MedicationOnlySummary, ComprehensiveOrderSummary, EmergencyOrderSummary]
    metadata: SummaryMetadata
    errors: List[str] = []
    
class SummaryMetadata(BaseModel):
    bundle_analysis: Dict[str, Any]
    llm_provider: str
    model_version: str
    confidence_score: float
    clinical_complexity: str
```

### API Integration Architecture

**Service Layer Integration:**
```python
class ClinicalSummaryService:
    def __init__(self):
        self.bundle_analyzer = FHIRBundleAnalyzer()
        self.llm_summarizer = StructuredClinicalSummarizer()
        self.request_tracker = RequestTracker()
        
    async def generate_summary(
        self, 
        fhir_bundle: Dict[str, Any],
        clinical_role: str,
        request_id: str
    ) -> ClinicalSummaryResponse:
        # Orchestrate full summarization pipeline
```

**Request Processing Pipeline:**
1. **Request Validation:** Validate FHIR bundle structure and required fields
2. **Bundle Analysis:** Analyze content and select appropriate schema
3. **LLM Summarization:** Generate structured summary with Instructor
4. **Response Assembly:** Create comprehensive response with metadata
5. **Logging & Metrics:** Track performance and clinical outcomes

### Additional API Endpoints

**Health Check Endpoint:**
```python
@app.get("/fhir/summarize/health")
async def health_check() -> HealthResponse:
    """System health and dependency status"""
```

**Schema Information Endpoint:**  
```python
@app.get("/fhir/summarize/schemas")
async def get_available_schemas() -> SchemaInfoResponse:
    """Available Pydantic schemas and their use cases"""
```

**Batch Processing Endpoint:**
```python
@app.post("/fhir/summarize/batch", response_model=BatchSummaryResponse)
async def summarize_batch(
    requests: List[FHIRSummarizationRequest]
) -> BatchSummaryResponse:
    """Process multiple FHIR bundles in batch"""
```

## Implementation Details

### File Structure
```
src/nl_fhir/
├── api/
│   ├── endpoints/
│   │   ├── clinical_summary.py        # Main summarization endpoints
│   │   ├── health.py                  # Health and status endpoints
│   │   └── batch_processing.py        # Batch operation endpoints
│   ├── models/
│   │   ├── request_models.py          # API request schemas  
│   │   ├── response_models.py         # API response schemas
│   │   └── error_models.py           # Error response schemas
│   └── middleware/
│       ├── request_tracking.py        # Request ID and logging
│       ├── performance_monitoring.py   # Metrics collection
│       └── error_handling.py         # Global error handling
└── services/
    └── clinical_summary_service.py    # Business logic orchestration
```

### Performance Monitoring

**Metrics Collection:**
```python
class PerformanceMetrics:
    def track_request(self, request_id: str, metadata: Dict):
        # Request tracking and performance monitoring
        
    def record_processing_time(self, request_id: str, stage: str, duration_ms: float):
        # Stage-by-stage performance tracking
        
    def track_llm_usage(self, model: str, tokens_used: int, cost: float):
        # LLM API usage monitoring
```

**Key Performance Indicators:**
- Request processing time (target <500ms)
- LLM API response time and token usage
- Error rates by category (validation, LLM, schema)
- Clinical role usage patterns
- Bundle complexity distribution

### Error Handling Strategy

**Error Categories:**
```python
class APIErrorHandler:
    def handle_validation_error(self, error: ValidationError) -> ErrorResponse:
        # FHIR bundle or request validation failures
        
    def handle_llm_error(self, error: LLMError) -> ErrorResponse:
        # OpenAI API failures or timeout errors
        
    def handle_schema_error(self, error: SchemaError) -> ErrorResponse:
        # Pydantic schema validation failures
        
    def handle_system_error(self, error: Exception) -> ErrorResponse:
        # Unexpected system errors
```

**Error Response Format:**
```python
class ErrorResponse(BaseModel):
    status: Literal["error"]
    error_type: str
    error_message: str  
    error_code: str
    request_id: str
    timestamp: datetime
    retry_after: Optional[int] = None
    support_info: str
```

## Testing Requirements

### Unit Tests
- [ ] Test API endpoint request/response handling
- [ ] Validate error handling for different failure scenarios
- [ ] Test request validation and sanitization
- [ ] Verify performance metrics collection

### Integration Tests  
- [ ] End-to-end API calls with real FHIR bundles
- [ ] Test service layer integration with LLM and bundle analyzer
- [ ] Validate batch processing functionality
- [ ] Test health check and monitoring endpoints

### Performance Tests
- [ ] Load testing with concurrent requests
- [ ] Response time testing under various bundle sizes
- [ ] Memory usage profiling under sustained load
- [ ] LLM API rate limit handling

### API Contract Tests
- [ ] OpenAPI schema validation 
- [ ] Request/response model compatibility
- [ ] Error response format consistency
- [ ] Backward compatibility with client integrations

## Definition of Done

- [ ] All API endpoints implemented with proper FastAPI integration
- [ ] Request tracking and performance monitoring functional
- [ ] Error handling covers all identified failure scenarios  
- [ ] Role-based summary customization working correctly
- [ ] Performance targets achieved (<500ms response time)
- [ ] Unit tests achieve >90% code coverage
- [ ] Integration tests validate end-to-end functionality
- [ ] Load testing confirms production readiness
- [ ] API documentation generated and reviewed
- [ ] Security review completed for API endpoints
- [ ] Monitoring and alerting configured
- [ ] Code review completed and approved

## Dependencies

**Blocked By:**
- Story 4.1 (Pydantic models for response schemas)
- Story 4.2 (LLM service for summarization)  
- Story 4.3 (Bundle analysis for request processing)

**Blocks:**
- Epic 5 deployment (requires production-ready API)

**External Dependencies:**
- FastAPI framework and async support
- Prometheus or similar for metrics collection
- Logging infrastructure (structured logging)
- Load balancer and API gateway configuration

## Production Configuration

### Environment Variables
```bash
# API Configuration  
API_HOST=0.0.0.0
API_PORT=8000
API_WORKERS=4
API_TIMEOUT=30

# Performance Settings
MAX_CONCURRENT_REQUESTS=100
REQUEST_TIMEOUT_MS=30000
BATCH_SIZE_LIMIT=10

# Monitoring
METRICS_ENABLED=true
STRUCTURED_LOGGING=true
LOG_LEVEL=INFO

# LLM Integration
OPENAI_API_KEY=sk-...
LLM_RATE_LIMIT_RPM=1000
LLM_TIMEOUT_MS=15000
```

### Deployment Requirements
- Container orchestration (Docker + Kubernetes)
- Load balancing with health check integration
- API gateway for rate limiting and authentication
- Monitoring dashboard for key metrics
- Log aggregation and alerting

## Clinical Integration Requirements

**Clinical Workflow Support:**
- Role-based summary customization for different clinical users
- Integration with EHR systems for order verification workflows  
- Support for clinical review and approval processes
- Audit logging for clinical documentation requirements

**Clinical Validation:**
- Physician review of API response formats and clinical appropriateness
- Validation that summaries support clinical decision-making workflows
- Confirmation of integration compatibility with clinical systems

## Notes for Development

**API Design Principles:**
1. **RESTful Design:** Follow REST conventions for predictable API behavior
2. **Async Processing:** Use FastAPI async capabilities for performance
3. **Comprehensive Errors:** Provide actionable error messages for debugging
4. **Observable:** Include detailed logging and metrics for production monitoring

**Security Considerations:**
- Input validation and sanitization for all requests
- Rate limiting to prevent API abuse
- Structured logging without sensitive clinical data
- API authentication and authorization (future enhancement)

**Clinical Safety:**
- Never modify or lose clinical information during API processing
- Maintain audit trails for all clinical summary generation
- Provide clear error messages for clinical staff when issues occur